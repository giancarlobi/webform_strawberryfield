<?php
/**
 * @file
 * Contains strawberryfield.module.
 */

use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Url;
use Drupal\webform\WebformSubmissionForm;
use Drupal\Core\Entity\ContentEntityInterface;
use Drupal\file\Entity\File;

/**
 * Alters a webform to help with embbeding in a node crud context.
 *
 * Implements hook_form_alter()
 *
 * @param $form
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 * @param $form_id
 */
function webform_strawberryfield_form_alter(&$form,FormStateInterface $form_state, $form_id) {

  //@TODO if wizard make elements of progress-marker direct links to that wizard page
  if (strpos($form_id, 'webform_') === FALSE || strpos($form_id, 'node_') === 0) {
    return;
  }

  /** @var \Drupal\webform\WebformSubmissionForm $submission_form */
  $submission_form = $form_state->getFormObject();
  $form['#attached']['library'][] = 'webform_strawberryfield/webform_strawberryfield.nodeactions.toggle';

  if (strpos($form_id, 'webform_submission') === 0
    && $submission_form instanceof WebformSubmissionForm) {

    // @TODO check if we should use instead \Drupal\webform\WebformSubmissionForm::isAjax
    // I'm not totally convinced since we could be "ajaxifying" a webform here
    // that was not set as such in it's saved settings.

    /** @var  \Drupal\webform\Entity\WebformSubmission $webform_submission */
    $webform_submission = $submission_form->getEntity();

    $isWidget = FALSE;
    // @see \Drupal\webform_strawberryfield\Controller @var $data_defaults
    if (array_key_exists('strawberry_field_widget_state_id', $webform_submission->getData())) {
      $isWidget = TRUE;
      // Since we are just using webform to act as a widget, we tell workspace module all is safe here.
      //@TODO this is giving issues. Workspace can not serialize Webformsubmission form
      // Probably related to some dependency injection that includes and open DB reference
      //$form_state->set('workspace_safe', true);
    }

    if (!$isWidget ) {
      return;
    }
    if (isset($form['actions']['reset'])) {
      $form['actions']['reset']['#submit'] = ['webform_strawberryfield_widget_reset'];
    }

    /* @TODO make this a valid switch
    // We should not make close object available if inline
    // add a close model button
    $query = \Drupal::request()->query->all();
    $is_ajax = (!empty($query['ajax_form'])) ? TRUE : FALSE;
    $webform_close_controller_url = Url::fromRoute(
    'webform_strawberryfield.close_modal_webform');
    if ($is_ajax) {
    $form['actions']['closemodal'] = [
    '#type' => 'link',
    '#title' => t('Close Window'),
    '#url' => $webform_close_controller_url,
    '#attributes' => [
    'class' => [
    'use-ajax',
    'button',
    ],
    ],
    '#weight' => 100,
    ];
    }*/

    if ($form_state->get('current_page') === 'webform_preview') {
      /** @var \Drupal\webform\WebformSubmissionForm $submission_form */
      $submission_form = $form_state->getFormObject();

      foreach ($form['elements'] as $key => &$element) {
        if (isset($element['#type']) && ($element['#type'] == 'webform_wizard_page')) {
          $form['actions']['edit_wizard_page_'.$key][] = [
            '#type' => 'submit',
            '#value' => 'edit '.$element['#title'],
            '#submit' => [
              'webform_strawberryfield_go_to_page',
            ],
            '#attributes' => [
              'class' => ['js-webform-novalidate'],
            ],
            '#ajax' => [
              'callback' => [$submission_form, 'submitAjaxForm'],
              'event' => 'click',
              'disable-refocus' => true,
              'effect' => 'fade',
              'speed' => 1000,
              'progress' => [
                'type' => 'throbber',
                'message' => '',
              ]
            ],
            '#page' => $key,
          ];
        }
      }
    }
  }
}

/**
 * Custom Jump-to-a-webform-page wizard callback.
 *
 * @param array $form
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 */
function webform_strawberryfield_go_to_page(array &$form, FormStateInterface $form_state) {

  /** @var \Drupal\webform\WebformSubmissionForm $submission_form */
  $submission_form = $form_state->getFormObject();

  /* @TODO: Use this valuable page number for something.
  $trigger = $form_state->getTriggeringElement();
  $current_page = $form_state->get('current_page');
  $wizard_page_id = $trigger['#page'];
   */

  // Submit using Mr. Wizard of WebOz.
  $submission_form->gotoPage($form, $form_state);
}

/**
 * Custom Reset Webform callback.
 *
 * This callback only resets to initial values but never resets whole state.
 * Needed to avoid our Webform widget to disconnect from its temp storage.
 *
 * @param array $form
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 */
function webform_strawberryfield_widget_reset(array &$form, FormStateInterface $form_state) {

  /** @var \Drupal\webform\WebformSubmissionForm $submission_form */
  $submission_form = $form_state->getFormObject();

  /** @var  \Drupal\webform\Entity\WebformSubmission $webform_submission */
  $webform_submission = $submission_form->getEntity();


  /** @var  \Drupal\webform\WebformInterface $webform */
  $webform = $webform_submission->getWebform();

  // @TODO investigate how to use \Drupal\webform\WebformSubmissionInterface::getOriginalData
  // Instead of copy, store, restore way i'm applying here.

  // Iterate over our own passed from field data
  $keeparound = array();
  foreach ($webform_submission->getData() as $keys => $data) {
    if (strpos($keys, 'strawberry_field') !== FALSE) {
      $keeparound[$keys] =  $data;
    }
  }
  // We should always have at least 3 keys
  // "strawberry_field_widget_state_id"
  // "strawberry_field_widget_source_entity_uuid"
  // "strawberry_field_stored_values"
  // @see \Drupal\webform_strawberryfield\Controller @var $data_defaults

  $restored_data = array();
  if (!empty($keeparound)) {
    // This brings stored data to the outside so webform can see it again
    $restored_data = $keeparound + $keeparound['strawberry_field_stored_values'];
  }

  // Call the original reset
  $submission_form->reset($form, $form_state);

  // Give submission our original values!
  $form_state->getFormObject()->getEntity()->setData($restored_data);
}

/**
 * Totally cosmetic hide/display main entity save button when in webform mode.
 *
 * Implements hook_FORM_ID_form_alter()
 *
 * @param $form
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 * @param $form_id
 */
function webform_strawberryfield_form_node_form_alter(&$form, FormStateInterface &$form_state, $form_id) {
  //$node = $form_state->getFormObject()->getEntity();
  // Means this form has a webform widget

  if (isset($form_state->getStorage()['webform_machine_name'])){
    $input = $form_state->getUserInput();

    if ((!isset($input['_triggering_element_name'])) || (isset($input['_triggering_element_value']) && $input['_triggering_element_value']!='Save Metadata')) {
      foreach ($form['actions'] as $key => &$buttons) {
        if ($key == 'delete') {
          $buttons['#access'] = FALSE;
        }
      }
    }
  }
}

/**
 * Implements hook_theme().
 */
function webform_strawberryfield_theme() {
  $info = [
  'webform_metadata_nominatim' => [
    'render element' => 'element',
  ]
    ];
  return $info;
}

/**
 * Prepares variables for location composite element templates.
 *
 * Default template: webform-metadata-nominatim.html.twig.
 *
 * @param array $variables
 *   An associative array containing:
 *   - element: An associative array containing the properties of the element.
 */
function template_preprocess_webform_metadata_nominatim(array &$variables) {
  $variables['content'] = $variables['element'];
  unset($variables['content']['value']);
  unset($variables['content']['nominatim']);
  unset($variables['content']['feature']);
  $variables['fetchbox'] = $variables['element']['value'];
  $variables['fetchbox_button'] = $variables['element']['nominatim'];
  $variables['fetchbox_table'] = $variables['element']['feature'];


}